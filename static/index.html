<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hixi</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 100vh; width: 100vw; }
        html, body { margin: 0; padding: 0; height: 100%; }
        .chart-container { width: 300px; height: 200px; }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // This javascript certified Vibe-Coded™. Watashiwa backend developer desu.

        // Palette
        const bixiRed = '#ee3124'
        const ebixiBlue = '#0083d5'

        const map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);

        function createChartPopup(stationId, stationName) {
            const container = document.createElement('div');
            container.innerHTML = `<div><strong>${stationName}</strong></div><div class='chart-container'><canvas id='chart-${stationId}' width='300' height='200'></canvas></div>`;
            fetch(`/stations/${stationId}`)
                .then(res => res.json())
                .then(data => {
                    const ctx = container.querySelector(`#chart-${stationId}`).getContext('2d');
                    const labels = data.map(row => {
                        const d = new Date(row[0] * 1000);
                        return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false });
                    });
                    const bikesAvailable = data.map(row => row[1]);
                    const ebikesAvailable = data.map(row => row[2]);

                    function makeGradient(ctx, color) {
                        const gradient = ctx.createLinearGradient(0, 0, 0, 200);
                        gradient.addColorStop(0, color + 'CC'); // near line, more opaque
                        gradient.addColorStop(1, color + '00'); // bottom, transparent
                        return gradient;
                    }

                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: labels,
                            datasets: [
                                {
                                    label: 'Classique',
                                    data: bikesAvailable,
                                    borderColor: bixiRed,
                                    backgroundColor: makeGradient(ctx, bixiRed),
                                    fill: true,
                                    pointRadius: 0,
                                    pointHoverRadius: 0
                                },
                                {
                                    label: 'Électrique',
                                    data: ebikesAvailable,
                                    borderColor: ebixiBlue,
                                    backgroundColor: makeGradient(ctx, ebixiBlue),
                                    fill: true,
                                    pointRadius: 0,
                                    pointHoverRadius: 0
                                }
                            ]
                        },
                        options: {
                            responsive: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    display: true,
                                    ticks: {
                                        callback: function(val, idx) { return labels[idx]; }
                                    }
                                },
                                y: {
                                    display: true,
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                })
                .catch(() => {
                    container.innerHTML += '<div>Failed to load chart data.</div>';
                });
            return container;
        }

        fetch('/stations')
            .then(response => response.json())
            .then(geojson => {
                const geoLayer = L.geoJSON(geojson, {
                    pointToLayer: function (feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: 6,
                            fillColor: bixiRed,
                            color: '#a51d13', // darker red outline
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 1
                        });
                    },
                    onEachFeature: function (feature, layer) {
                        if (feature.properties && feature.properties.id && feature.properties.name) {
                            layer.on('click', function() {
                                const popupContent = createChartPopup(feature.properties.id, feature.properties.name);
                                layer.bindPopup(popupContent).openPopup();
                            });
                        }
                    }
                }).addTo(map);
                if (geoLayer.getBounds().isValid()) {
                    map.fitBounds(geoLayer.getBounds());
                }
            })
            .catch(err => {
                alert('Failed to load stations: ' + err);
            });
    </script>
</body>
</html>